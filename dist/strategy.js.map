{"version":3,"sources":["../src/strategy.js"],"names":[],"mappings":"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","file":"strategy.js","sourcesContent":["/**\n * Validate using the validatorjs library as a strategy for react-validation-mixin\n *\n * @see https://github.com/skaterdav85/validatorjs\n * @see https://jurassix.gitbooks.io/docs-react-validation-mixin/content/overview/strategies.html\n */\n\n'use strict';\n\nvar Validator = require('validatorjs');\n\nvar strategy = {\n    /**\n     * Used to create this.validatorTypes in a React component and to be passed to validate or validateServer\n     *\n     * @param {Object} rules List of rules as specified by validatorjs\n     * @param {Object} messages Optional list of custom messages as specified by validatorjs\n     * @param {Function} callback if specified, called to allow customisation of validator\n     * @returns {Object}\n     */\n    createSchema(rules, messages, callback) {\n        return {\n            rules,\n            messages,\n            callback\n        };\n    },\n    /**\n     * Same as createSchema, but the rules are disabled until activateRule is called\n     *\n     * @param {Object} rules List of rules as specified by validatorjs\n     * @param {Object} messages Optional list of custom messages as specified by validatorjs\n     * @param {Function} callback if specified, called to allow customisation of validator\n     * @returns {Object}\n     */\n    createInactiveSchema(rules, messages, callback) {\n        var schema = this.createSchema(rules, messages, callback);\n        schema.activeRules = [];\n\n        return schema;\n    },\n    /**\n     * Active a specific rule\n     *\n     * @param {Object} schema As created by createInactiveSchema\n     * @param {Object} rule Name of the rule as a key in schema.rules\n     */\n    activateRule(schema, rule) {\n        if (typeof schema.activeRules !== 'undefined' && schema.activeRules.indexOf(rule) === -1) {\n            schema.activeRules.push(rule);\n        }\n    },\n    /**\n     * Create a validator from submitted data and a schema\n     *\n     * @param {Object} data The data submitted\n     * @param {Object} schema Contains rules and custom error messages\n     * @param {Boolean} forceActive Whether to force all rules to be active even if not activated\n     * @returns {Validator}\n     */\n    createValidator(data, schema, forceActive) {\n        var rules = {};\n\n        // Only add active rules to the validator if an initially inactive schema has been created.\n        if (typeof schema.activeRules !== 'undefined') {\n            // Force all rules to be active if specified\n            if (forceActive) {\n                schema.activeRules = Object.keys(schema.rules);\n            }\n\n            for (let i in schema.activeRules) {\n                let ruleName = schema.activeRules[i];\n\n                rules[ruleName] = schema.rules[ruleName];\n            }\n        } else {\n            rules = schema.rules;\n        }\n\n        var validator = new Validator(data, rules, schema.messages);\n\n        // If a callback has been specified on the schema, call it to allow customisation of the validator\n        if (typeof schema.callback === 'function') {\n            schema.callback(validator);\n        }\n\n        return validator;\n    },\n    /**\n     * Called by react-validation-mixin\n     *\n     * @param {Object} data The data submitted\n     * @param {Object} schema Contains rules and custom error messages\n     * @param {Object} options Contains name of element being validated and previous errors\n     * @param {Function} callback Called and passed the errors after validation\n     */\n    validate(data, schema, options, callback) {\n        // If the whole form has been submitted, then activate all rules\n        var forceActive = !options.key;\n        var validator = this.createValidator(data, schema, forceActive);\n\n        var getErrors = () => {\n            // If a single element is being validated, just get those errors.\n            // Otherwise get all of them.\n            if (options.key) {\n                options.prevErrors[options.key] = validator.errors.get(options.key);\n                callback(options.prevErrors);\n            } else {\n                callback(validator.errors.all());\n            }\n        };\n\n        // Run the validator asynchronously in case any async rules have been added\n        validator.checkAsync(getErrors, getErrors);\n    },\n    /**\n     * Validate server-side returning a Promise to easier handle results.\n     * All inactive rules will be forced to activate.\n     *\n     * @param {Object} data The data submitted\n     * @param {Object} schema Contains rules and custom error messages\n     * @returns {Promise}\n     */\n    validateServer(data, schema) {\n        var validator = this.createValidator(data, schema, true);\n\n        return new Promise((resolve, reject) => {\n            validator.checkAsync(\n                () => {\n                    resolve();\n                },\n                () => {\n                    var e = new this.Error('A validation error occurred');\n                    e.errors = validator.errors.all();\n\n                    reject(e);\n                }\n            );\n        });\n    },\n    /**\n     * Extension of the built-in Error. Created by validateServer when validation fails.\n     * Exists so that middleware can check it with instanceof: if (err instanceof strategy.Error)\n     *\n     * @property {Object} errors Contains the error messages by field name.\n     */\n    Error: class extends Error {}\n};\n\n// If in the browser, export as a global window variable.\nif (typeof window !== \"undefined\" && typeof window.strategy === \"undefined\") {\n    window.strategy = strategy;\n}\n\n// If being loaded as a module\nif (typeof module !== \"undefined\") {\n    module.exports = strategy;\n}\n"]}