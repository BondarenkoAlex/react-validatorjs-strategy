{"version":3,"sources":["webpack:///webpack/bootstrap b64c007d4766298d345e","webpack:///./src/strategy.js","webpack:///external \"Validator\""],"names":[],"mappings":"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","file":"strategy.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b64c007d4766298d345e\n **/","/**\r\n * Validate using the validatorjs library as a strategy for react-validation-mixin\r\n *\r\n * @see https://github.com/skaterdav85/validatorjs\r\n * @see https://jurassix.gitbooks.io/docs-react-validation-mixin/content/overview/strategies.html\r\n */\r\n\r\n'use strict';\r\n\r\nvar Validator = require('validatorjs');\r\n\r\nvar strategy = {\r\n    /**\r\n     * Used to create this.validatorTypes in a React component and to be passed to validate or validateServer\r\n     *\r\n     * @param {Object} rules List of rules as specified by validatorjs\r\n     * @param {Object} messages Optional list of custom messages as specified by validatorjs\r\n     * @param {Function} callback if specified, called to allow customisation of validator\r\n     * @returns {Object}\r\n     */\r\n    createSchema(rules, messages, callback) {\r\n        return {\r\n            rules,\r\n            messages,\r\n            callback\r\n        };\r\n    },\r\n    /**\r\n     * Same as createSchema, but the rules are disabled until activateRule is called\r\n     *\r\n     * @param {Object} rules List of rules as specified by validatorjs\r\n     * @param {Object} messages Optional list of custom messages as specified by validatorjs\r\n     * @param {Function} callback if specified, called to allow customisation of validator\r\n     * @returns {Object}\r\n     */\r\n    createInactiveSchema(rules, messages, callback) {\r\n        var schema = this.createSchema(rules, messages, callback);\r\n        schema.activeRules = [];\r\n\r\n        return schema;\r\n    },\r\n    /**\r\n     * Active a specific rule\r\n     *\r\n     * @param {Object} schema As created by createInactiveSchema\r\n     * @param {Object} rule Name of the rule as a key in schema.rules\r\n     */\r\n    activateRule(schema, rule) {\r\n        if (typeof schema.activeRules !== 'undefined' && schema.activeRules.indexOf(rule) === -1) {\r\n            schema.activeRules.push(rule);\r\n        }\r\n    },\r\n    /**\r\n     * Create a validator from submitted data and a schema\r\n     *\r\n     * @param {Object} data The data submitted\r\n     * @param {Object} schema Contains rules and custom error messages\r\n     * @param {Boolean} forceActive Whether to force all rules to be active even if not activated\r\n     * @returns {Validator}\r\n     */\r\n    createValidator(data, schema, forceActive) {\r\n        var rules = {};\r\n\r\n        // Only add active rules to the validator if an initially inactive schema has been created.\r\n        if (typeof schema.activeRules !== 'undefined') {\r\n            // Force all rules to be active if specified\r\n            if (forceActive) {\r\n                schema.activeRules = Object.keys(schema.rules);\r\n            }\r\n\r\n            for (let i in schema.activeRules) {\r\n                let ruleName = schema.activeRules[i];\r\n\r\n                rules[ruleName] = schema.rules[ruleName];\r\n            }\r\n        } else {\r\n            rules = schema.rules;\r\n        }\r\n\r\n        var validator = new Validator(data, rules, schema.messages);\r\n\r\n        // If a callback has been specified on the schema, call it to allow customisation of the validator\r\n        if (typeof schema.callback === 'function') {\r\n            schema.callback(validator);\r\n        }\r\n\r\n        return validator;\r\n    },\r\n    /**\r\n     * Called by react-validation-mixin\r\n     *\r\n     * @param {Object} data The data submitted\r\n     * @param {Object} schema Contains rules and custom error messages\r\n     * @param {Object} options Contains name of element being validated and previous errors\r\n     * @param {Function} callback Called and passed the errors after validation\r\n     */\r\n    validate(data, schema, options, callback) {\r\n        // If the whole form has been submitted, then activate all rules\r\n        var forceActive = !options.key;\r\n        var validator = this.createValidator(data, schema, forceActive);\r\n\r\n        var getErrors = () => {\r\n            // If a single element is being validated, just get those errors.\r\n            // Otherwise get all of them.\r\n            if (options.key) {\r\n                options.prevErrors[options.key] = validator.errors.get(options.key);\r\n                callback(options.prevErrors);\r\n            } else {\r\n                callback(validator.errors.all());\r\n            }\r\n        };\r\n\r\n        // Run the validator asynchronously in case any async rules have been added\r\n        validator.checkAsync(getErrors, getErrors);\r\n    },\r\n    /**\r\n     * Validate server-side returning a Promise to easier handle results.\r\n     * All inactive rules will be forced to activate.\r\n     *\r\n     * @param {Object} data The data submitted\r\n     * @param {Object} schema Contains rules and custom error messages\r\n     * @returns {Promise}\r\n     */\r\n    validateServer(data, schema) {\r\n        var validator = this.createValidator(data, schema, true);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            validator.checkAsync(\r\n                () => {\r\n                    resolve();\r\n                },\r\n                () => {\r\n                    var e = new this.Error('A validation error occurred');\r\n                    e.errors = validator.errors.all();\r\n\r\n                    reject(e);\r\n                }\r\n            );\r\n        });\r\n    },\r\n    /**\r\n     * Extension of the built-in Error. Created by validateServer when validation fails.\r\n     * Exists so that middleware can check it with instanceof: if (err instanceof strategy.Error)\r\n     *\r\n     * @property {Object} errors Contains the error messages by field name.\r\n     */\r\n    Error: class extends Error {}\r\n};\r\n\r\n// If in the browser, export as a global window variable. Otherwise, export as a module.\r\nif (typeof window !== \"undefined\") {\r\n    window.strategy = strategy;\r\n} else {\r\n    module.exports = strategy;\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/strategy.js\n **/","module.exports = Validator;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"Validator\"\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}